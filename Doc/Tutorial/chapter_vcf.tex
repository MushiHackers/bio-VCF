\chapter{Bio.VCF: handling VCF and phased files}

Since this functionality is based on \verb|pyVCF|
package, this chapter is partly based on the original \verb|pyVCF| documentation. Not all of the original functionality
is described below, therefore for further details of \verb|Bio.VCF| module, please see
\href{http://pyvcf.readthedocs.io/en/latest/INTRO.html}{pyVCF}.

\section{VCF.Reader class}

\verb|VCF.Reader| class takes a file-like object and acts as reader. It is intended to parse the content of each record
based on the data types specified in the meta-information lines, specifically the \verb|##INFO| and \verb|##FORMAT| lines.
If these lines are missing or incomplete it will check against the reserved types mentioned in the spec.
Failing that, it will just return strings.
\\
\\

\noindent Regarding the coordinates associated with each instance:

\begin{description}
  \item[\texttt{POS}] \

    per VCF specification, is the one-based index (the first base of the contig has an index of 1)
    of the first base of the \verb|REF| sequence. Positions are sorted numerically,
    in increasing order.

  \item[\texttt{start, end}] \

    denote the coordinates of the entire \verb|REF| sequence in the zero-based, half-open coordinate
    system (see \href{http://genomewiki.ucsc.edu/index.php/Coordinate_Transforms}{Coordinate\_Transforms}), where
    the first base of the contig has an index of 0, and the interval runs up to, but does not include, the base
    at the end index. This indexing scheme is analagous to Python slice notation.

  \item[\texttt{affected\_start, affected\_end}] \

    are also in the zero-based, half-open coordinate system. These coordinates indicate the precise region
    of the reference genome actually affected by the events denoted in \verb|ALT| (i.e., the minimum
    \verb|affected_start| and maximum \verb|affected_end|).
    For SNPs and structural variants, the affected region includes all bases of \verb|REF|, including the
    first base (i.e., \verb|affected_start| = \verb|start| = \verb|POS| - 1).
    For deletions, the region includes all bases of \verb|REF| except the first base, which flanks
    upstream the actual deletion event, per VCF specification.
    For insertions, the \verb|affected_start| and \verb|affected_end| coordinates represent a
    0 bp-length region between the two flanking bases (i.e., \verb|affected_start| = \verb|affected_end|).
    This is analagous to Python slice notation (see \href{http://stackoverflow.com/a/2947881/38140}{Stackoverflow}).
    Neither the upstream nor downstream flanking bases are included in the region.

\end{description}

\noindent \verb|samples| and \verb|genotype|\\

not being the title of any column, are left lowercase. The format of the fixed
fields is from the spec. Comma-separated lists in the \verb|VCF| are converted to lists. In particular,
one-entry \verb|VCF| lists are converted to one-entry Python lists (see, e.g., \verb|Record.ALT|).
Semicolon-delimited lists of key=value pairs are converted to Python dictionaries, with flags being given a True value.

\
\



\noindent Metadata regarding the VCF file itself can be investigated through the following attributes:

\

\verb|Reader.metadata|, \verb|Reader.infos|, \verb|Reader.filters|, \verb|Reader.formats|, \verb|Reader.samples|.

\

\noindent The attributes of a \verb|Record| object are the 8 fixed fields from the VCF spec: \

\

\verb|Record.CHROM|, \verb|Record.POS|, \verb|Record.ID|, \verb|Record.REF|, \verb|Record.ALT|, \verb|Record.QUAL| \
  \verb|Record.FILTER|, \verb|Record.INFO|

\

\noindent Plus attributes to handle genotype information:

\

\verb|Record.FORMAT|, \verb|Record.samples|, \verb|Record.genotype|.

\

\noindent Suppose we have a VCF file and want to see all the records in it. We might simply create a VCF.Reader object:

\begin{verbatim}
>>> from Bio.VCF import parser
>>> vcf_reader = parser.Reader(open('example-4.0.vcf', 'r'))
>>> for record in vcf_reader:
...     print record
Record(CHROM=20, POS=14370, REF=G, ALT=[A])
Record(CHROM=20, POS=17330, REF=T, ALT=[A])
Record(CHROM=20, POS=1110696, REF=A, ALT=[G, T])
Record(CHROM=20, POS=1230237, REF=T, ALT=[None])
Record(CHROM=20, POS=1234567, REF=GTCT, ALT=[G, GTACT])
\end{verbatim}


\noindent Now, we are interested in position and alteration type of the first record from the VCF file. We can obtain the information by typing:

\begin{verbatim}
>>> record = next(vcf_reader)
>>> print record.POS
14370
>>> print record.ALT
[A]
>>> print record.INFO['AF']
[0.5]
\end{verbatim}

\noindent Moreover there are a number of convenience methods and properties for each \verb|VCF.Record| object allowing you to analyse VCF object:

\begin{verbatim}
>>> print record.num_called, record.call_rate, record.num_unknown
3 1.0 0
>>> print record.num_hom_ref, record.num_het, record.num_hom_alt
1 1 1
>>> print record.nucl_diversity, record.aaf, record.heterozygosity
0.6 [0.5] 0.5
>>> print record.get_hets()
[Call(sample=NA00002, CallData(GT=1|0, GQ=48, DP=8, HQ=[51, 51]))]
>>> print record.is_snp, record.is_indel, record.is_transition, record.is_deletion
True False True False
>>> print record.var_type, record.var_subtype
snp ts
>>> print record.is_monomorphic
False
\end{verbatim}

\verb|record.FORMAT| will be a string specifying the format of the genotype fields. In case the \verb|FORMAT|
 column does not exist, \verb|record.FORMAT| is None. Finally, \verb|record.samples| is a list of dictionaries
 containing the parsed sample column and \verb|record.genotype| is a way of looking up genotypes by sample name:

 \begin{verbatim}
>>> record = next(vcf_reader)
>>> for sample in record.samples:
...     print sample['GT']
0|0
0|1
0/0
>>> print record.genotype('NA00001')['GT']
0|0
\end{verbatim}

\noindent The genotypes are represented by \verb|Call| objects, which have three attributes: the corresponding \verb|Record|
\verb|site|, the sample name in \verb|sample| and a dictionary of call data in \verb|data|:

\begin{verbatim}
>>> call = record.genotype('NA00001')
>>> print call.site
Record(CHROM=20, POS=17330, REF=T, ALT=[A])
>>> print call.sample
NA00001
>>> print call.data
CallData(GT=0|0, GQ=49, DP=3, HQ=[58, 50])
\end{verbatim}

\noindent There are also a number of methods for \verb|Call| objects:

\begin{verbatim}
>>> print call.called, call.gt_type, call.gt_bases, call.phased
True 0 T|T True
\end{verbatim}

\noindent User can be interested in some details of the VCF file, for example file's creation date, samples included
and filters. The functionality of this module supports retrieval of such data:

\begin{verbatim}
>>> vcf_reader.metadata['fileDate']
'20090805'
>>> vcf_reader.samples
['NA00001', 'NA00002', 'NA00003']
>>> vcf_reader.filters
OrderedDict([('q10', Filter(id='q10', desc='Quality below 10')), \
('s50', Filter(id='s50', desc='Less than 50% of samples have data'))])
>>> vcf_reader.infos['AA'].desc
'Ancestral Allele'
\end{verbatim}

\noindent When you are interested in \verb|ALT| records, you can interrogate them to achieve information:

\begin{verbatim}
>>> reader = parser.Reader(open('example-4.1-bnd.vcf'))
>>> _ = next(reader); row = next(reader)
>>> print row
Record(CHROM=1, POS=2, REF=T, ALT=[T[2:3[])
>>> bnd = row.ALT[0]
>>> print bnd.withinMainAssembly, bnd.orientation, bnd.remoteOrientation,
bnd.connectingSequence
True False True T
\end{verbatim}

\subsection{Record parameters}

\noindent Below there is a brief description of other methods and parameters available for Reader's records.

\begin{description}
  \item[\texttt{aaf}] \

   A list of allele frequencies of alternate alleles. NOTE: Denominator calc’ed from \_called\_ genotypes.

  \item[\texttt{alleles}] \

   list of alleles. [0] = REF, [1:] = ALTS

  \item[\texttt{call\_rate}] \

  The fraction of genotypes that were actually called.

  \item[\texttt{end}] \

  zero-based, half-open end coordinate of \verb|REF|.

  \item[\texttt{get\_hets()}] \

    The list of het genotypes.

  \item[\texttt{get\_hom\_alts()}] \

    The list of hom alt genotypes.

  \item[\texttt{get\_hom\_refs()}] \

    The list of hom ref genotypes.

  \item[\texttt{heterozygosity}] \

    Heterozygosity of a site. Heterozygosity gives the probability that two randomly chosen chromosomes from the
    population have different alleles, giving a measure of the degree of polymorphism in a population.
    If there are i alleles with frequency p\_i, H=1-sum\_i(p\_i\^2)

\end{description}

\noindent There are also a number of boolean methods, such as: \\

\verb|is_deletion|, \verb|is_filtered|, \verb|is_indel|, \verb|is_monomorphic|, \verb|is_snp|, \verb|is_svp|, \verb|is_transition|.

\subsection{Additional utilities}

\noindent Below there is a brief description of additional utilities for VCF files.


\begin{description}

    \item[\texttt{utils.walk\_together(*readers, **kwargs)}] \

    Simultaneously iteratate over two or more \verb|VCF| readers. For each genomic position with a variant,
    return a list of size equal to the number of VCF readers. This list contains the \verb|VCF| record from
    readers that have this variant, and None for readers that don’t have it. The caller must make sure
    that inputs are sorted in the same way and use the same reference otherwise behaviour is undefined.\\
    \
   \noindent\verb|Args|:\\
            \verb|vcf_record_sort_key|: \\

    Function that takes a VCF record and returns a
    tuple that can be used as a key for comparing and sorting \verb|VCF| records across all readers.
    This tuple defines what it means for two variants to be equal (eg. whether it’s only their
    position or also their allele values), and implicitly determines the chromosome ordering since
    the tuple’s 1st element is typically the chromosome name (or calculated from it).


    \item[\texttt{vcf.utils.trim\_common\_suffix(*sequences)}] \

    Trim a list of sequences by removing the longest common suffix while leaving all of them at least one
    character in length. Standard convention with VCF is to place an indel at the left-most position,
    but some tools add additional context to the right of the sequences (e.g. samtools).
    These common suffixes are undesirable when comparing variants, for example in variant databases.

    \begin{verbatim}
    >>> trim_common_suffix('TATATATA', 'TATATA')
    ['TAT', 'T']
    \end{verbatim}

    \begin{verbatim}
    >>> trim_common_suffix('ACCCCC', 'ACCCCCCCC', 'ACCCCCCC', 'ACCCCCCCCC')
    ['A', 'ACCC', 'ACC', 'ACCCC']
    \end{verbatim}

   
    \end{description}

\section{VCF.Writer class}

\noindent The \verb|VCF.Writer| class provides a way of writing a VCF file.
\verb|VCF.parser| module supports \verb|close()|, \verb|flush()| and \verb|write_record()| methods.
\
\noindent Currently, when writing new VCF file you must specify a template \verb|VCF.Reader| object
which provides the metadata, like this:

\begin{verbatim}
>>> from Bio.VCF import parser
>>> vcf_reader = parser.Reader(filename='tb.vcf.gz')
>>> vcf_writer = parser.Writer(open('/dev/null', 'w'), vcf_reader)
>>> for record in vcf_reader:
...     vcf_writer.write_record(record)
\end{verbatim}




\section{Retrieving records from VCF file}

\noindent This chapter gives an overview of the functionality of fetch methods included in \verb|VCF| \verb|parser| module.
Those functions enable users to retrieve particular records from VCF file describing structural variants,
depending on provided argument - for example interval of positions within which we seek for structural variants, a list
of such positions or feature type within which structural variants are present.
\

\noindent Functionality of those fetch methods includes retrieving structural variants corresponding to ranges
provided in BED files as well as features from GFF files. If you are not familiar with BED file format
you might be interested in \href{http://www.ensembl.org/info/website/upload/bed.html}{BED} and
\href{http://gmod.org/wiki/GFF3}{GFF}.

\
\noindent Most of implementation is based on \verb|pybedtools| module - \href{https://daler.github.io/pybedtools/}{pybedtools},
which support many file formats including VCF, BED and GFF, therefore \verb|pybedtools| package is required.
\

\noindent Due to enormous sizes of some BED and GFF files, some fetch methods are intended to enable user to provide
stream of particular GFF/BED file from chosen database. It is a beneficial solution allowing users to avoid
the necessity of saving very big files to local disc.
\

\noindent Below there is a brief description of each fetch method.
All of them have arguments \verb|verbose| and \verb|vcf| specifying if result should be printed to stdout
and whether new VCF.Reader object should be created, respectively. When running fetch on two files, one of them must be
saved to local disc.

\begin{description}
  \item[\texttt{fetch\_bed(bed\_file, verbose = True, vcf = None)}] \

    Fetches VCF file records that correspond to regions included in a BED file.
    Fetch is based on pybedtools 'intersect' method and returns a BedTool / VCF.Reader object of selected features.
    BED file must be specified.

  \item[\texttt{fetch\_bed\_fsock(stream, verbose = False, vcf=None)}] \

    This fetch works exactly the same as fetch\_bed(), except the BED file is not required.
    Intervals used for intersection with a VCF file are provided in stream object of chosen BED file.
    This method returns a BedTool object of selected VCF features or new VCF.Reader object.
    Stream of gzipped BED file is required.

  \item[\texttt{fetch\_multilocal(chrom, local\_list, verbose = False, vcf = None)}] \

    Fetches VCF records that correspond to intervals provided in 'local\_list'.
    Local\_list must be a list of tuples (start, end), where start and end coordinates are in the
    zero-based, half-open coordinate system. Function returns selected records as a BedTool object
    or new VCF.Reader object. Chromosome must be specified.

  \item[\texttt{fetch(chrom, interval = None, verbose = True, vcf=None)}] \

    Fetches those records from VCF file that correspond to selected chromosome and
    fit in selected interval (if provided).
    This method creates one-line pybedtool feature based on selected chromosome (and interval = [start,stop]),
    and then uses it in pybedtools intersection method.
    Function returns BedTool object representing selected VCF records or new VCF.Reader object.
    Chromosome must be specified and interval is optional.

  \item[\texttt{fetch\_gff(gff\_file, chrom, feature\_type, location = None, verbose = False, vcf = None)}] \
  
    This method enables to select desired features from a GFF/GFF2/GFF3 file and fetch VCF records
    that correspond to position of those features. Fetch is based on pybedtools 'intersection' method and returns
    a BedTool object of chosen VCF records or new VCF.Reader object.
    Gff file, chromosome and feature type are required.
    Selection of desired features from a GFF/GFF2/GFF3 file with a specified location is possible when
    provided optional parameter 'location=[start,end]'.

  \item[\texttt{fetch\_gff\_fsock(self, stream, chrom, feature\_type, location = None, verbose = False, vcf = None)}] \
  
    This method works exactly the same as fetch\_gff(), except the GFF file is not required.
    The GFF file is replaced with a stream object from chosen database.
    Method returns a BedTool object of selected VCF records or new VCF.Reader object.
    Stream of gzipped file must be provided.

\end{description}


\noindent The following sections present exemplary use of fetch methods.


\subsection{Create VCF.Reader object}
\label{sec:object}


\noindent Since all fetch methods are included in VCF.Reader class, we need to create \verb|Reader| object. But first of all,
we need to import Bio.VCF library:


\begin{verbatim}
>>> from Bio import VCF
>>> from VCF import parser

\end{verbatim}

\noindent and then create a VCF.Reader obcject. We can either create object from a local file or we can provide fsock
of corresponding VCF file:


\begin{verbatim}
>>> vcf=parser.Reader(open('Tests/VCF/chr13.vcf'))

\end{verbatim}

\subsubsection{Fetching records depending on BED/GFF file}


\noindent Suppose we have a BED file with positions of CTCF motif binding sites. We want to collect all structural variants
located within those sites. If we have this BED file locally on our computer, then we should simply run:


\begin{verbatim}
>>> vcf.fetch_bed('chr13bed.bed')

\end{verbatim}

\noindent or if we don't, we should provide a stream of chosen BED file and use:

\begin{verbatim}
>>> stream="ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606/BED/bed_chr_13.bed.gz"
>>> vcf.fetch_bed_fsock(stream)

\end{verbatim}


\noindent Selected structural variants are returned in BedTools object (if vcf = None) and can be easily accessed, for example
if we want to see all information of every selected record:


\begin{verbatim}
>>> bed = vcf.fetch_bed('chr13bed.bed')
>>> for b in bed:
>>>     print (b.fields)
['chr13', '10', '.', 'G', 'GGT', '.', 'PASS', 'DP=91;SS=1;SSC=2;GPV=3.0109E-23;SPV=5.8324E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','0/1:.:36:13:22:62.86%:2,11,1,21']
['chr13', '20', '.', 'GT', 'G', '.', 'PASS', 'DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:28:5:22:81.48%:0,5,1,21']
['chr13', '40', '.', 'AAAC', 'A', '.', 'PASS', 'DP=42;SS=1;SSC=12;GPV=7.3092E-18;SPV=6.278E-2',
'GT:GQ:DP:RD:AD:FREQ:DP4','0/1:.:13:4:9:69.23%:4,0,9,0']
['chr13', '50', '.', 'TC', 'T', '.', 'PASS', 'DP=41;SS=1;SSC=2;GPV=9.8874E-23;SPV=5.3659E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:22:1:21:95.45%:1,0,15,6']
['chr13', '60', '.', 'T', 'TTAA', '.', 'PASS', 'DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:12:0:12:100%:0,0,0,12']
\end{verbatim}


\noindent Similarly, we can extract structural variants corresponding to positions of chosen features from GFF file. Suppose
we have a GFF3 file of Homo sapiens, but we are interested only in variants located within pseudogenes
at 13th chromosome. \verb|fetch_gff()| method is what we need:


\begin{verbatim}
>>> vcf.fetch_gff('HS_fetch_gff.gff3', '13', 'pseudogene')
\end{verbatim}


\noindent What is more, if we want variant within pseudogenes which are within specific positions, we can add
\verb|location| argument:


\begin{verbatim}
>>> vcf.fetch_gff('HS_fetch_gff.gff3', '13', 'pseudogene', location=[1, 18270822])
Finding SV corresponding to pseudogene and chosen position
chr13	20	.	GT	G	.	PASS	DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:28:5:22:81.48%:0,5,1,21
chr13	30	.	AC	A	.	PASS	DP=22;SS=1;SSC=7;GPV=1.3117E-10;SPV=1.9481E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:10:2:8:80%:0,2,0,8
chr13	40	.	AAAC	A	.	PASS	DP=42;SS=1;SSC=12;GPV=7.3092E-18;SPV=6.278E-2	GT:GQ:DP:RD:AD:FREQ:DP4
0/1:.:13:4:9:69.23%:4,0,9,0
chr13	50	.	TC	T	.	PASS	DP=41;SS=1;SSC=2;GPV=9.8874E-23;SPV=5.3659E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:22:1:21:95.45%:1,0,15,6
chr13	60	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
chr13	9542346	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
\end{verbatim}


\noindent As in case of fetch depending on BED file, we can use stream of GFF file instead of local file.


\subsubsection{Fetching records depending on interval}


\noindent We might have a VCF file which have records referring to different chromosomes. In such case, we want to be able to
analyze only those variants that are located on chromosome of our interest. We can simply use \verb|fetch()| method
on our \verb|vcf| object, but as we want to analyze fetched records further, we should use argument specifying
new vcf.Reader object:


\begin{verbatim}
>>> v=vcf.fetch('chr13',vcf='new_vcf')
>>> v
<parser.Reader object at 0x7eff4df8f2b0>

\end{verbatim}

\noindent Now, when we have all variants located on chromosome 13, we can choose only those within specified intervals:


\begin{verbatim}
>>> v.fetch_multilocal('chr13',[[10, 30], [80, 100], [85837129, 100000000]])
chr13	20	.	GT	G	.	PASS	DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:28:5:22:81.48%:0,5,1,21
chr13	30	.	AC	A	.	PASS	DP=22;SS=1;SSC=7;GPV=1.3117E-10;SPV=1.9481E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:10:2:8:80%:0,2,0,8
chr13	85837130	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
<BedTool(/tmp/pybedtools.dbyw5lct.tmp)>

\end{verbatim}

\noindent VCF file created after \verb|vcf.fetch| is saved to local disc and can be easily achieved with \verb|VCF.Reader()| anytime needed.



\section{VCF Filters}
\noindent Not all of original filters (from https://github.com/jamescasbon/PyVCF) work. Until the error is  fixed we recommend using our version. 

\subsection{The filters\_new.py script}
\noindent Filtering a VCF file based on some properties of interest is a common enough operation that PyVCF offers an extensible script.\\
\\
\noindent Existing Filter's Classes:\\

\verb|Bio.VCF.filters_new.Filter.SQ| \\

\verb|Bio.VCF.filters_new.Filter.VGQ| \\

\verb|Bio.VCF.filters_new.Filter.DPS| \\

\verb|Bio.VCF.filters_new.Filter.APS| \\

\verb|Bio.VCF.filters_new.Filter.SNP| \\

\verb|Bio.VCF.filters_new.Filter.CHR| \\

\verb|Bio.VCF.filters_new.Filter.POS| \\



\subsection{Adding a filter}
\noindent To add your own filter you should write it by example shown below. First you should create function of your filter in \verb|Bio.VCF.filter_new.Filter| class and than recognition condition in recognition function.

\begin{verbatim}  
(...)

class Filter:

    def your_filter(self, record,val=None): 
        try:
            if record.your_argument in val:
                return True
            else:
                return False 
        except:
            sys.exit("your note for exception")

    (....)

    def recognition(self, name, record,argument):
        if name=="your_filter"':
            return self.your_filter(record,argument)

\end{verbatim}

\noindent To use this filter firstly you have to import \verb|filters_new.py| from its directory. 
\noindent Than you have to create Base object with VCF file which you want to filter and optionaly name of output file. After that you must use \verb|filtering| funcion on base object with dict of filter and list of their parameters.

\noindent You have several options for filtering: by  Site Quality \verb|Bio.VCF.filters_new.Filter.SQ|, Variant Genotype Quality \verb|Bio.VCF.filters_new.Filter.VGQ|, Depth per sample \verb|Bio.VCF.filters_new.Filter.DPS|, Avg Depth Per Sample \verb|Bio.VCF.filters_new.Filter.APS|, Snp Only \verb|Bio.VCF.filters_new.Filter.SNP|, chromosomes \verb|Bio.VCF.filters_new.Filter.CHR|, position \verb|Bio.VCF.filters_new.Filter.POS|.


\noindent Example of using filters from filters\_new.py file:
\begin{verbatim}
>>>from Bio.VCF import filters_new
>>>base=filters_new.Base('./Tests/VCF/1kg.sites.vcf')
>>>base.filtering({'POS':[106544, 99080], SNP:[]})
\end{verbatim}

\noindent If you have any problem with filters\_new.py, please contast us. 

\subsection{sample\_filters.py script}
\noindent \verb|Bio.VCF.sample_filters| are functions created to filter VCF files by haplotyp's sample.
Usually we're interseted just in specified mutants, thats why it's very helpfull to get information to further analysis only about this variants.

\noindent How to use it:

\begin{verbatim}
positional arguments:
  file          VCF file to filter

optional arguments:
  -h, --help    show this help message and exit
  -o outfile    File to write out filtered samples
  -f filters    Comma-separated list of sample indices or names to filter
  -i, --invert  Keep rather than discard the filtered samples
  -q, --quiet   Less output
\end{verbatim}

\noindent Example of usage:
\begin{verbatim}
$ python ../Bio/VCF/scripts/vcf_sample_filter.py VCF/example-4.1.vcf
Samples:
0: NA00001
1: NA00002
2: NA00003

$python ../Bio/VCF/scripts/vcf_sample_filter.py VCF/example-4.1.vcf -f 1,2 --quiet
##fileformat=VCFv4.1
##fileDate=20090805
##source=myImputationProgramV3.1
##reference=file:///seq/references/1000GenomesPilot-NCBI36.fasta
##phasing=partial
##INFO=<ID=NS,Number=1,Type=Integer,Description="Number of Samples With Data">
##INFO=<ID=DP,Number=1,Type=Integer,Description="Total Depth">
##INFO=<ID=AF,Number=A,Type=Float,Description="Allele Frequency">
##INFO=<ID=AA,Number=1,Type=String,Description="Ancestral Allele">
##INFO=<ID=DB,Number=0,Type=Flag,Description="dbSNP membership, build 129">
##INFO=<ID=H2,Number=0,Type=Flag,Description="HapMap2 membership">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=GQ,Number=1,Type=Integer,Description="Genotype Quality">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Read Depth">
##FORMAT=<ID=HQ,Number=2,Type=Integer,Description="Haplotype Quality">
##FILTER=<ID=q10,Description="Quality below 10">
##FILTER=<ID=s50,Description="Less than 50% of samples have data">
##contig=<ID=20,length=62435964>
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	NA00001
20	14370	rs6054257	G	A	29	PASS	NS=3;DP=14;AF=0.5;DB;H2	GT:GQ:DP:HQ	0|0:48:1:51,51
20	17330	.	T	A	3	q10	NS=3;DP=11;AF=0.017	GT:GQ:DP:HQ	0|0:49:3:58,50
20	1110696	rs6040355	A	G,T	67	PASS	NS=2;DP=10;AF=0.333,0.667;AA=T;DB	GT:GQ:DP:HQ	1|2:21:6:23,27
20	1230237	.	T	.	47	PASS	NS=3;DP=13;AA=T	GT:GQ:DP:HQ	0|0:54:7:56,60
20	1234567	microsat1	GTC	G,GTCT	50	PASS	NS=3;DP=9;AA=G	GT:GQ:DP	0/1:35:4
\end{verbatim}   


\section{Available VCF Databases}

\noindent \verb|Bio.VCF.databases| is a Biopython module that supports \verb|1001 Genomes| and \verb|dbSNP| databases.
Since most of VCF files are of enormous sizes, it is convenient to use streams instead of local files.
Functionality of this package enables users to search through above-mentioned databases, and use selected streams
of VCF files as \verb|VCF.Reader| objects in further analysis.


\noindent If you are not familiar with \verb|1001 Genomes| and \verb|dbSNP| databases you might be interested in
\href{http://1001genomes.org/}{1001 Genomes} and \href{https://www.ncbi.nlm.nih.gov/SNP/}{dbSNP}. However, following
sections provide brief description of methods searching through both databases as well as some information about them.


\subsection{1001 Genomes database}
\label{sec:object}


\verb|1001 Genomes| database was launched to discover whole-genome variation of the \verb|Arabidopsis Thaliana| strains.
\verb|Bio.VCf.databases| module supports current database's version which includes analysis of 1135 genomes achieved
during the first phase of the project.
Searching through the database can be based on strain's name, ec number, eco type, as well as on information of its
origin - such as country, longitude or latitude.


\noindent Below there is a brief description of \verb|thousandgenomes()| methods:


\begin{description}
  \item[\texttt{thousandgenomes(name, ecotype, ecnumber, country, longitude, latitude)}] \

    This method enables to search through \verb|1001 Genomes| database for VCF file corresponding to selected
    Arabidopsis Thaliana strain, origin country or longitude and/or latitude where Arabidopsis Thaliana live.

    Country name must be chosen from: "USA", "FRA", "CZE", "AUT", "KGZ", "TJK", "SWE", "UK", "GER", "KAZ",
    "BEL", "CPV", "ESP", "RUS", "NED", "FIN", "SUI", "ITA", "IRL", "POR", "EST", "DEN", "IND", "LTU", "JPN", "POL", "NOR",
    "CAN", "UKR", "AZE", "GEO", "ARM", "MAR", "CRO", "BUL", "GRC", "SVK", "ROU", "UZB", "SRB", "CHN", "IRN", "LBN", "MAR",
    "AFG".\\
\vspace{5mm}
    Longitude and latitude should be provided as an interval - longitude = (int1, int2), latitude = (int1,int2).
    Strain names, eco types and ec numbers are unique, country, while longitude and latitude enables users to seek for
    multiple VCF files corresponding to selected features.
    Method returns VCF.Reader object of selected VCF file stream from 1001 Genomes Database or a list of
    such VCF.Reader objects.

\item[\texttt{download(vcf\_reader, path\_filename)}] \

    Downloads VCF file corresponding to stream on which provided VCF.Reader object is initialized.
    VCF.Reader object as well as download directory and filename are required.

\item[\texttt{merge(vcf\_list,vcf\_template,vcf\_name)}] \

    Method creates VCF.Reader object from provided list of VCF.Reader objects.
    It is based on VCF.Writer class and uses Writer.write\_record() method - new sorted VCF file is saved to
    bio-VCF/Bio/VCF directory.
    Template VCF.Reader object and name for new VCF file are required.

\end{description}

\noindent Let's try some functionality of the module:
\vspace{5mm}
\noindent Suppose we want to analyse structural variants identified in "CYR" strain of Arabidopsis Thaliana. First of all,
we need to find VCF file corresponding to our selected strain. To do so, we can simply type:


\begin{verbatim}
>>> from Bio.VCF import databases
>>> vcf = databases.thousandgenomes("CYR")
>>> vcf
<Bio.VCF.parser.Reader object at 0x7f4bf49feef0>

\end{verbatim}


\noindent Now, we can continue analysis for example by running methods from VCF.Reader class.


\noindent We may also be interested in retrieving all structural variants that are identified in strains occupying a particular
territory, such as area of longitude (-73.1494, -73.1492) and latitude (40.9063, 40.9064). Module's \verb|thousandgenomes()|
method can manage this:


\begin{verbatim}
>>> vcf_list = databases.thousandgenomes(longitude=(-73.1494, -73.1492), latitude=(40.9063, 40.9064))
>>> vcf_list
[<Bio.VCF.parser.Reader object at 0x7f4bf4a0d978>, <Bio.VCF.parser.Reader object at 0x7f4bf4a1e080>]

\end{verbatim}


\noindent Method returned two VCF.Reader objects which we can analyse further or simply download to local disc:


\begin{verbatim}
>>> for v in vcf_list:
>>>     databases.download(v,'database_download.gz')
\end{verbatim}

\subsection{dbSNP database}

\verb|dbSNP| Is the NCBI Short Genetic Variations database. It catalogs short variations in nucleotide sequences from a wide range of organisms. 
\verb|Bio.VCf.databases| module can be used to obtain avaiable VCF files from dbSNP. List of organism for which VCF files exists can be found in supplementary file \verb|organisms.txt|. The database is regulary updated. User can update list od organisms using attached methods. Searching through the database can be based on organism and taxon ID proposed in file \verb|organisms.txt| and a chosen chromosome. Unfortunatelly dbSNP does not contain human SNPs divided into chromosomes. User can operate only on a very big file (350GB).
\vspace{5mm}
\noindent Below there is a brief description of \verb|dbSNP| methods:

\begin{description}
  \item[\texttt{dbSNP\_download(organism\_taxon, chromosome = None)}] \

    This method enables to search through \verb|dbSNP| database for VCF file corresponding to selected
    organism, taxon and chromosome.
    
    Organism and corresponding taxon ID must be chosen from list of organisms in \verb|organisms.txt|. User can update this list by running
    \verb|check_VCF()| method.
    
    Chromosome must be chosen from existing chromosomes in given organism. Leaving \verb|chromosome=None| will cause loading VCF file
    containing all the chromosomes (but not every organism has this file).
    
    Method returns VCF.Reader object of selected VCF file stream from dbSNP.
    
    \item[\texttt{check\_VCF()}] \
    
    This method enables to update organisms list in \verb|organisms.txt|. dbSNP is regullary updated. If you can't find chosen organisms on 
    the list we recommend running this method. 

\end{description}

\noindent Let's try some functionality of the module:
\vspace{5mm}
\noindent Suppose we want to analyse SNPs found in chromosome 2R in fruitfly. We check \verb|organisms.txt| where we can find identifier 
fruitfly\_7227.

\begin{verbatim}
>>> from Bio.VCF import databases
>>> vcf = databases.dbSNP_download('fruitfly_7227',chromosome='2R')
>>> vcf
<Bio.VCF.parser.Reader object at 0x7f1d813f14d0>
\end{verbatim}

\noindent Now we can continue our analysis using methods proposed in VCF.Reader class.
\vspace{5mm}
\noindent We can also want to analyse all SNPs found for flycatcher:

\begin{verbatim}
>>> vcf = databases.dbSNP_download('flycatcher_59894')
>>> vcf
<Bio.VCF.parser.Reader object at 0x7f1d82c83ad0>
\end{verbatim}

\noindent If you want to check if new VCF files are avaiable just run:

\begin{verbatim}
>>> from Bio.VCF import databases
>>> databases.check_VCF()
Connecting to database...
Searching for VCF files...
Searching for VCF files...
Searching for VCF files...
Searching for VCF files...
Searching for VCF files...
.
.
.
List updated.
\end{verbatim}
    
    
\section {Retrieving records from phasing files}
%todo Hans

This chapter gives an overview of the usage of phasing files parser included in \verb|Bio.VCF| \verb|phase| module.
This module makes handling haplotype data easier, allowing users to retrieve particular records from phasing files
and even filtering SNPs by matching them to those included in VCF file.

The whole module is specifficaly written for handling data from \href{ftp://ftp.hapmap.org/hapmap/phasing/2009-02\_phaseIII/HapMap3\_r2/}{HapMap 3} project.
Format of the data handled by functions is as staded in \href{ftp://ftp.hapmap.org/hapmap/phasing/2009-02\_phaseIII/HapMap3\_r2/hapmap3\_r2\_phasing\_summary.doc}{hapmap3\_r2\_phasing\_summary.doc},
but also assuming that SNPs in those files are sorted increasingly by position.


\subsection{Parsing and reading phasing files}

Phasing data can be read as \verb|VCF.PhasedReader| object. It is similiar to \verb|VCF.Reader| class - works with both compressed (.gz) and
uncompressed files, can take fsocks (streams) and filenames as input, with specified encoding (default is ascii).
\verb|VCF.PhasedReader| holds information extracted from the name of the file (if available), haplotypes, and SNP's in form of \verb|VCF._PhasedRecord| objects.
It also contains several useful functions explained further in the coresponding subsections in \verb|VCF.PhasedReader functions| section below.
Important thing is, if you are downloading the .phased file to your computer, rather not change the file name as it gives important
information not stated anywhere in the file. Files without original name will be parsed normally but will lack in information like:
\begin{enumerate}
  \item chromosome
  \item region
  \item duos or trios, if the file is for unrelated haplotypes
  \end{enumerate}

\subsubsection{Creating VCF.PhasedReader objects}

\noindent Suppose we have a phasing file downloaded from the \href{ftp://ftp.hapmap.org/hapmap/phasing/2009-02\_phaseIII/HapMap3\_r2/}{HapMap 3} site.
We can read it in several ways, in example supporting only the filename:

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> phase_reader = PhasedReader('hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> phase_reader
<Bio.VCF.phase.PhasedReader object at 0x7fee0c0445c0>

\end{verbatim}

\noindent or with opening the file first:

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> phase_file = open('hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> phase_reader = PhasedReader(fsock = phase_file)
>>> phase_reader
<Bio.VCF.phase.PhasedReader object at 0x7fee0c04bd30>

\end{verbatim}

\noindent If the file is compressed (.gz), the parser will try to guess it and uncompress it without stating anything, but it is advised that the uncompressed argument is set
to true:

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> phase_reader = PhasedReader('hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased.gz',
compressed=True)
>>> phase_reader
<Bio.VCF.phase.PhasedReader object at 0x7fedf6df1278>

\end{verbatim}

\subsubsection{Exploring data held by VCF.PhasedReader}

\noindent Data extracted from the filename is stored in the \verb|VCF.PhasedReader.filedata| dict.

\begin{verbatim}
>>> phase_reader.filedata
{'region': 'yri', 'chrom': '10', 'data_type': 'duos'}

\end{verbatim}

\noindent It is possible to get to the particular information by calling its key from dict:

\begin{verbatim}
>>> phase_reader.filedata['region']
'yri'
>>> phase_reader.filedata['chrom']
'10'
>>> phase_reader.filedata['data_type']
'duos'

\end{verbatim}

\noindent Haplotypes included in the file are stored in the haplotypes list, as \verb|_Haplotype objects|:

\begin{verbatim}
>>> phase_reader.haplotypes
[<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e828>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e898>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e908>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e940>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e9b0>,
.
.
.

\end{verbatim}

\noindent Let's see the first haplotype in the file:

\begin{verbatim}
>>> phase_reader.haplotypes[0]
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e828>
>>> print(phase_reader.haplotypes[0])
NA18855, transmitted: True

\end{verbatim}

\noindent The \verb|_Haplotype| object holds information about the name of haplotype and if it is transmitted:

\begin{verbatim}
>>> phase_reader.haplotypes[0].name
'NA18855'
>>> phase_reader.haplotypes[0].is_transmitted
True

\end{verbatim}

\subsubsection{Parsing phasing files with VCF.PhasedReader}

\noindent To get the first (and then next, and then next...) line of the file, you just call \verb|next()| on the \verb|PhasedReader|:

\begin{verbatim}
>>> rec = next(phase_reader)
>>> rec
<Bio.VCF.phase._PhasedRecord object at 0x7fb16ed7f6d8>
>>> print(rec)
Record(rs12255619 at 88481: C, A, A, A, A, A, A, A, A, A, A, A)

\end{verbatim}

\noindent Parsing the phasing file by iterating over it is also possible:

\begin{verbatim}
>>> for rec in phase_reader:
...     print(rec)
...
Record(rs12255619 at 88481: C, A, A, A, A, A, A, A, A, A, A, A)
Record(rs11252546 at 94427: T, T, T, T, T, T, T, T, C, T, T, T)
Record(rs17156316 at 191762: T, T, T, T, T, T, T, C, C, T, T, T)
Record(rs10903451 at 193471: A, A, A, A, G, G, A, A, A, A, A, G)
Record(rs11250575 at 199448: T, C, C, C, C, C, C, C, C, C, C, C)
.
.
.

\end{verbatim}

\noindent Let's explore what is stored in the \verb|_PhasedRecord|:
\begin{enumerate}
\item rsID of the SNP
\begin{verbatim}
>>> rec.rsID
'rs12255619'
\end{verbatim}

\item record position on the chromosome:
\begin{verbatim}
>>> rec.pos
88481
\end{verbatim}

\item samples included in the record (as list of \verb|_Sample objects|):
\begin{verbatim}
>>> rec.samples
[<Bio.VCF.phase._Sample object at 0x7f38a3d20a90>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d048>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d080>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d0b8>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d160>,
.
.
.
\end{verbatim}
\end{enumerate}

\noindent The \verb|_Sample| object corresponds to the nucleotide in the particular haplotype for the particular SNP:

\begin{verbatim}
>>> rec.samples[0]
<Bio.VCF.phase._Sample object at 0x7f38a3d20a90>
>>> rec.samples[0].rsID, rec.samples[0].haplotype.name, rec.samples[0].nucleotide
('rs12255619', 'NA18855', 'C')
\end{verbatim}

\noindent \verb|_Sample| also holds information if the particular SNP for the haplotype exists and if it's unresolved:

\begin{verbatim}
>>> rec.samples[0].exists, rec.samples[0].is_unresolved
(True, False)
\end{verbatim}

\noindent There is also the is\verb|_not_matching_snp| argument, but it is further discussed in the \verb|VCF.PhasedReader.fetch()|
section.

\subsection{Writing phasing files with VCF.PhasedWriter}

\noindent The \verb|VCF.PhasedWriter| works similarily to the \verb|VCF.Writer|. You need to supply the stream to save the contents and
the template (\verb|PhasedReader| object):

\begin{verbatim}
>>> phase_reader = PhasedReader('hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> out = open('somenewname.phased','w')
>>> phase_writer = PhasedWriter(stream = out, template = phase_reader)
>>> phase_writer
<Bio.VCF.phase.PhasedWriter object at 0x7f991e9ba4e0>
\end{verbatim}

\noindent and then, you write in the records you want, i.e fetched from the VCF file:

\begin{verbatim}
>>> for rec in phase_reader.fetch(filename = './Tests/VCF/chr10.vcf'):
...     phase_writer.write(rec)
...
rs12255619	88481	C A A A A A A A A A A A
rs1904671	1004603	A G. A A A A G. G. A A A A
rs11812734	31713857	A G A A G G G G A G G G

\end{verbatim}

\noindent The output in this case should be stored in the somenewname.phased file.

\subsection{VCF.PhasedReader functions}

\subsubsection{VCF.PhasedReader.fetch() - Fetching SNP's from VCF file}

\noindent The fetch metod retrieves SNPs corresponding to those in provided VCF file. It creates \verb|VCF.Reader|
and filters it to have only the SNP's, then finds the matching ones in the phasing file. It returns the next \verb|PhasedReader| object, but only with matching records.
It takes the same arguments as \verb|VCF.Reader| when it is created (see in the section about \verb|VCF.Reader| above) and a few more:

\begin{enumerate}
  \item \verb|verbose| (default True) - if the found records should be printed out
  \item \verb|vcf| (default None) - the argument for VCF.Reader.fetch, see above
  \item \verb|not_matching_snp| (default ".") - what should be put after the nucleotide not matching any of the alleles in the VCF.
  If \verb|None|, nucleotide is outputted normally.
\end{enumerate}

\noindent Remember that all the functions in the \verb|PhasedReader| objects, especially \verb|fetch()|, treats the phasing file as sorted by position.
\\

\noindent Suppose you wanted to filter the SNPs in the phasing files with the VCF file with some records for the same chromosome.
First you need to create the \verb|PhasedReader| object, and then fetch it by supplying the same arguments as you would when creating the VCF.Reader object.

\begin{verbatim}
>>> phase_reader = PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased.gz',
compressed = True)
>>> phase_reader.fetch(filename = 'Tests/VCF/chr10.vcf',compressed = True)
rs12255619	88481	C A A A A A A A A A A A
rs1904671	1004603	A G. A A A A G. G. A A A A
rs11812734	31713857	A G A A G G G G A G G G
<Bio.VCF.phase.PhasedReader object at 0x7f38a3d3d128>
\end{verbatim}

\noindent If you don't want dots, or any sign after the not-matching SNPs, set not\verb|_matching_snp| to \verb|None|:

\begin{verbatim}
>>> phase_reader.fetch(filename = 'Tests/VCF/chr10.vcf',not_matching_snp = None)
rs12255619	88481	C A A A A A A A A A A A
rs1904671	1004603	A G A A A A G G A A A A
rs11812734	31713857	A G A A G G G G A G G G
<Bio.VCF.phase.PhasedReader object at 0x7f38a3d20b70>
\end{verbatim}

\noindent Or if you don't want the lines to be printed and just have the new reader, simply change the \verb|verbose| to \verb|False|:

\begin{verbatim}
>>> phase_reader.fetch(filename = 'Tests/VCF/chr10.vcf',verbose=False)
<Bio.VCF.phase.PhasedReader object at 0x7f38a3d3d518>
\end{verbatim}

\subsubsection{VCF.PhasedReader.get\_specific\_snp(rsID) - Getting SNP with user-given rsID}

\noindent \verb|rsID| argument provides information on rsID of searched SNP.

\noindent As the output user receives a \verb|_PhasedRecord| object, which represents found SNP, or information that no SNP with given rsID was found.


\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> reader = PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> reader.get_snp_with_specific_id('rs2066314')
<Bio.VCF.phase._PhasedRecord object at 0x7fe67d7a7e50>

\end{verbatim}

\subsubsection{VCF.PhasedReader.get\_snp\_within\_range(pos1, pos2) - Getting SNPs within user-given range of positions}

\noindent \verb|pos1| and \verb|pos2| arguments stand for a beginning and an ending position of the range (respectively) within which we are looking for SNPs.

\noindent As the output user receives information on how many SNPs within given range were found and a list of \verb|_PhasedRecord| objects, where each of them represents
one found SNP, or information that no SNP within given range was found.

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> reader = PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> reader.get_snp_within_range(418076, 504032)
SNPs found: 3

[<Bio.VCF.phase._PhasedRecord object at 0x7f3e13b30dd0>,
<Bio.VCF.phase._PhasedRecord object at 0x7f3e13b30750>,
<Bio.VCF.phase._PhasedRecord object at 0x7f3e13b33150>]

\end{verbatim}

\subsection{VCF.PhasedReader.get\_snp\_with\_specific\_sample(haplotype, nucleotide) - Getting SNPs which contain user-given sample}

\noindent Haplotype argument provides information on the sample's haplotype name.
nucleotide argument provides the information on the sample's nucleotide ('A', 'T', 'G', 'C'). 

\noindent As the output user receives information whether the haplotype provided in the arguments is included in the given file (if not, corresponding information 
is being printed), how many SNPs containing searched sample were found and a list of \verb|_PhasedRecord| objects, where each of them represents one found SNP. If no SNP
meeting the requirements provided in the arguments was found, corresponding information is being printed. 

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> reader = PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> reader.get_snp_with_specific_sample('NA18855_B', 'T')
Searched haplotype is included in the given file...
SNPs found: 7

[<Bio.VCF.phase._PhasedRecord object at 0x7fe75042c7d0>,
 <Bio.VCF.phase._PhasedRecord object at 0x7fe75042c110>, 
<Bio.VCF.phase._PhasedRecord object at 0x7fe75042cb50>,
<Bio.VCF.phase._PhasedRecord object at 0x7fe75042ce90>, 
<Bio.VCF.phase._PhasedRecord object at 0x7fe75042f550>, 
<Bio.VCF.phase._PhasedRecord object at 0x7fe75042f890>, 
<Bio.VCF.phase._PhasedRecord object at 0x7fe75042f210>]
\end{verbatim}

\subsection{VCF.PhasedReader.get\_samples\_from\_specific\_hap(haplotype) - Getting samples within user-given haplotype}

\noindent Haplotype argument provides information on the name of the haplotype, within which user is searching for samples.

\subsection{VCF.PhasedReader.get\_snp\_with\_specific\_sample(haplotype) - Getting SNPs with user-given details of the searched sample}

\noindent Haplotype argument provides information on the name of the haplotype, within which user is searching for samples.

\noindent As the output user receives information whether the haplotype provided in the arguments is included in the given file (if not, corresponding information 
is being printed), how many samples within searched haplotype were found and a list of \verb|_Sample| objects, where each of them represents one found sample. Moreover,
information on the number of unresolved and not existing samples (within given haplotype), which are found during parsing a file, is being printed. If no sample 
meeting the requirements provided in the arguments was found, corresponding information is also being printed.

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> reader = PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> reader.get_samples_in_specific_hap('NA18855_NA18856_A')
Searched haplotype is included in the given file...
Samples found: 32
SNPs found unresolved: 0
SNPs found not existing: 0

[<Bio.VCF.phase._Sample object at 0x7fe75042fbd0>, <Bio.VCF.phase._Sample object at 0x7fe750435490>, <Bio.VCF.phase._Sample object at 0x7fe75042fc50>, <Bio.VCF.phase._Sample object at 0x7fe7504354d0>, <Bio.VCF.phase._Sample object at 0x7fe75042fc90>, <Bio.VCF.phase._Sample object at 0x7fe750435510>, <Bio.VCF.phase._Sample object at 0x7fe75042fcd0>, <Bio.VCF.phase._Sample object at 0x7fe750435550>, <Bio.VCF.phase._Sample object at 0x7fe75042fd10>, <Bio.VCF.phase._Sample object at 0x7fe750435050>, <Bio.VCF.phase._Sample object at 0x7fe75042fd50>, <Bio.VCF.phase._Sample object at 0x7fe750435090>, <Bio.VCF.phase._Sample object at 0x7fe75042fd90>, <Bio.VCF.phase._Sample object at 0x7fe7504350d0>, <Bio.VCF.phase._Sample object at 0x7fe75042fdd0>, <Bio.VCF.phase._Sample object at 0x7fe750435110>, <Bio.VCF.phase._Sample object at 0x7fe75042fe10>, <Bio.VCF.phase._Sample object at 0x7fe750435150>, <Bio.VCF.phase._Sample object at 0x7fe75042fe50>, <Bio.VCF.phase._Sample object at 0x7fe750435190>, <Bio.VCF.phase._Sample object at 0x7fe750435590>, <Bio.VCF.phase._Sample object at 0x7fe7504351d0>, <Bio.VCF.phase._Sample object at 0x7fe7504355d0>, <Bio.VCF.phase._Sample object at 0x7fe750435610>, <Bio.VCF.phase._Sample object at 0x7fe750435650>, <Bio.VCF.phase._Sample object at 0x7fe750435690>, <Bio.VCF.phase._Sample object at 0x7fe7504356d0>, <Bio.VCF.phase._Sample object at 0x7fe750435710>, <Bio.VCF.phase._Sample object at 0x7fe750435750>, <Bio.VCF.phase._Sample object at 0x7fe750435790>, <Bio.VCF.phase._Sample object at 0x7fe7504357d0>, <Bio.VCF.phase._Sample object at 0x7fe750435810>]
\end{verbatim}

\subsection{VCF.PhasedReader.get\_specific\_sample(rsID, haplotype) - Getting a sample with user-given details}

\noindent \verb|rsID| argument provides information on the rsID of SNP, within which user is searching for a specific sample.
haplotype argument provides information on the name of the haplotype, within which user is searching for a specific sample.

\noindent As the output user receives information whether the haplotype provided in the arguments is included in the given file (if not, corresponding information 
is being printed) and a \verb|_Sample| object, which represents found sample. Moreover, if searched sample turns out to be unresolved or not existing, corresponding
information is being printed. If no sample meeting the requirements provided in the arguments was found, corresponding information is also being printed.

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> reader = PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> reader.get_specific_sample('rs11252546', 'NA18855_NA18856_A')
Searched haplotype is included in the given file...
<Bio.VCF.phase._Sample object at 0x7f8bb5d4c7d0>
\end{verbatim}
