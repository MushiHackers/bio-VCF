\chapter{Bio.VCF: handling VCF and phased files}

Since this functionality is based on \verb|pyVCF|
package, this chapter is partly based on the original \verb|pyVCF| documentation. Not all of the original functionality
is described below, therefore for further details of \verb|Bio.VCF| module, please see
\href{http://pyvcf.readthedocs.io/en/latest/INTRO.html}{pyVCF}.

\section{VCF.Reader class}

\verb|VCF.Reader| class takes a file-like object and acts as reader. It is intended to parse the content of each record
based on the data types specified in the meta-information lines, specifically the \verb|##INFO| and \verb|##FORMAT| lines.
If these lines are missing or incomplete it will check against the reserved types mentioned in the spec.
Failing that, it will just return strings.



\noindent Regarding the coordinates associated with each instance:

\begin{description}
  \item[\texttt{POS}] \

    per VCF specification, is the one-based index (the first base of the contig has an index of 1)
    of the first base of the \verb|REF| sequence. Positions are sorted numerically,
    in increasing order.

  \item[\texttt{start}{ end}] \

    denote the coordinates of the entire \verb|REF| sequence in the zero-based, half-open coordinate
    system (see \href{http://genomewiki.ucsc.edu/index.php/Coordinate_Transforms}{Coordinate\_Transforms}), where
    the first base of the contig has an index of 0, and the interval runs up to, but does not include, the base
    at the end index. This indexing scheme is analagous to Python slice notation.

  \item[\texttt{affected\_start}{ affected\_end}] \

    are also in the zero-based, half-open coordinate system. These coordinates indicate the precise region
    of the reference genome actually affected by the events denoted in \verb|ALT| (i.e., the minimum
    \verb|affected_start| and maximum \verb|affected_end|).
    For SNPs and structural variants, the affected region includes all bases of \verb|REF|, including the
    first base (i.e., \verb|affected_start| = \verb|start| = \verb|POS| - 1).
    For deletions, the region includes all bases of \verb|REF| except the first base, which flanks
    upstream the actual deletion event, per VCF specification.
    For insertions, the \verb|affected_start| and \verb|affected_end| coordinates represent a
    0 bp-length region between the two flanking bases (i.e., \verb|affected_start| = \verb|affected_end|).
    This is analagous to Python slice notation (see \href{http://stackoverflow.com/a/2947881/38140}{Stackoverflow}).
    Neither the upstream nor downstream flanking bases are included in the region.

\end{description}

\noindent \verb|samples| and \verb|genotype|, not being the title of any column, are left lowercase. The format of the fixed
fields is from the spec. Comma-separated lists in the \verb|VCF| are converted to lists. In particular,
one-entry \verb|VCF| lists are converted to one-entry Python lists (see, e.g., \verb|Record.ALT|).
Semicolon-delimited lists of key=value pairs are converted to Python dictionaries, with flags being given a True value.


\noindent This module supports


\noindent Metadata regarding the VCF file itself can be investigated through the following attributes:

\

\verb|Reader.metadata|, \verb|Reader.infos|, \verb|Reader.filters|, \verb|Reader.formats|, \verb|Reader.samples|.

\

\noindent The attributes of a \verb|Record| object are the 8 fixed fields from the VCF spec: \

\

\verb|Record.CHROM|, \verb|Record.POS|, \verb|Record.ID|, \verb|Record.REF|, \verb|Record.ALT|, \verb|Record.QUAL| \
  \verb|Record.FILTER|, \verb|Record.INFO|

\

\noindent plus attributes to handle genotype information:

\

\verb|Record.FORMAT|, \verb|Record.samples|, \verb|Record.genotype|.

\

\noindent Suppose we have a VCF file and want to see all the records in it. We might simply create a VCF.Reader object:

\begin{verbatim}
>>> from Bio.VCF import parser
>>> vcf_reader = parser.Reader(open('example-4.0.vcf', 'r'))
>>> for record in vcf_reader:
...     print record
Record(CHROM=20, POS=14370, REF=G, ALT=[A])
Record(CHROM=20, POS=17330, REF=T, ALT=[A])
Record(CHROM=20, POS=1110696, REF=A, ALT=[G, T])
Record(CHROM=20, POS=1230237, REF=T, ALT=[None])
Record(CHROM=20, POS=1234567, REF=GTCT, ALT=[G, GTACT])
\end{verbatim}


\noindent Now, we are interested in position and alteration type of the first record from the VCF file. We can obtain the information by typing:

\begin{verbatim}
>>> record = next(vcf_reader)
>>> print record.POS
14370
>>> print record.ALT
[A]
>>> print record.INFO['AF']
[0.5]
\end{verbatim}

\noindent Moreover there are a number of convenience methods and properties for each \verb|VCF.Record| object allowing you to analyse VCF object:

\begin{verbatim}
>>> print record.num_called, record.call_rate, record.num_unknown
3 1.0 0
>>> print record.num_hom_ref, record.num_het, record.num_hom_alt
1 1 1
>>> print record.nucl_diversity, record.aaf, record.heterozygosity
0.6 [0.5] 0.5
>>> print record.get_hets()
[Call(sample=NA00002, CallData(GT=1|0, GQ=48, DP=8, HQ=[51, 51]))]
>>> print record.is_snp, record.is_indel, record.is_transition, record.is_deletion
True False True False
>>> print record.var_type, record.var_subtype
snp ts
>>> print record.is_monomorphic
False
\end{verbatim}

\verb|record.FORMAT| will be a string specifying the format of the genotype fields. In case the \verb|FORMAT|
 column does not exist, \verb|record.FORMAT| is None. Finally, \verb|record.samples| is a list of dictionaries
 containing the parsed sample column and \verb|record.genotype| is a way of looking up genotypes by sample name:

 \begin{verbatim}
>>> record = next(vcf_reader)
>>> for sample in record.samples:
...     print sample['GT']
0|0
0|1
0/0
>>> print record.genotype('NA00001')['GT']
0|0
\end{verbatim}

\noindent The genotypes are represented by \verb|Call| objects, which have three attributes: the corresponding \verb|Record|
\verb|site|, the sample name in \verb|sample| and a dictionary of call data in \verb|data|:

\begin{verbatim}
>>> call = record.genotype('NA00001')
>>> print call.site
Record(CHROM=20, POS=17330, REF=T, ALT=[A])
>>> print call.sample
NA00001
>>> print call.data
CallData(GT=0|0, GQ=49, DP=3, HQ=[58, 50])
\end{verbatim}

\noindent There are also a number of methods for \verb|Call| objects:

\begin{verbatim}
>>> print call.called, call.gt_type, call.gt_bases, call.phased
True 0 T|T True
\end{verbatim}

\noindent User can be interested in some details of the VCF file, for example file's creation date, samples included
and filters. The functionality of this module supports retrieval of such data:

\begin{verbatim}
>>> vcf_reader.metadata['fileDate']
'20090805'
>>> vcf_reader.samples
['NA00001', 'NA00002', 'NA00003']
>>> vcf_reader.filters
OrderedDict([('q10', Filter(id='q10', desc='Quality below 10')), \
('s50', Filter(id='s50', desc='Less than 50% of samples have data'))])
>>> vcf_reader.infos['AA'].desc
'Ancestral Allele'
\end{verbatim}

\noindent When you are interested in \verb|ALT| records, you can interrogate them to achieve information:

\begin{verbatim}
>>> reader = parser.Reader(open('example-4.1-bnd.vcf'))
>>> _ = next(reader); row = next(reader)
>>> print row
Record(CHROM=1, POS=2, REF=T, ALT=[T[2:3[])
>>> bnd = row.ALT[0]
>>> print bnd.withinMainAssembly, bnd.orientation, bnd.remoteOrientation, bnd.connectingSequence
True False True T
\end{verbatim}

\subsection{Record parameters}

\noindent Below there is a brief description of other methods and parameters available for Reader's records.

\begin{description}
  \item[\texttt{aaf}] \

   A list of allele frequencies of alternate alleles. NOTE: Denominator calc’ed from \_called\_ genotypes.

  \item[\texttt{alleles}] \

   list of alleles. [0] = REF, [1:] = ALTS

  \item[\texttt{call\_rate}] \

  The fraction of genotypes that were actually called.

  \item[\texttt{end}] \

  zero-based, half-open end coordinate of \verb|REF|.

  \item[\texttt{get\_hets()}] \

    The list of het genotypes.

  \item[\texttt{get\_hom\_alts()}] \

    The list of hom alt genotypes.

  \item[\texttt{get\_hom\_refs()}] \

    The list of hom ref genotypes.

  \item[\texttt{heterozygosity}] \

    Heterozygosity of a site. Heterozygosity gives the probability that two randomly chosen chromosomes from the
    population have different alleles, giving a measure of the degree of polymorphism in a population.
    If there are i alleles with frequency p\_i, H=1-sum\_i(p\_i\^2)

\end{description}

\noindent There are also a number of boolean methods, such as:

\verb|is_deletion|, \verb|is_filtered|, \verb|is_indel|, \verb|is_monomorphic|, \verb|is_snp|, \verb|is_svp|, \verb|is_transition|.

\subsection{Additional utilities}

\noindent Below there is a brief description of additional utilities for VCF files.


\begin{description}

    \item[\texttt{utils.walk\_together(*readers, **kwargs)}] \

    Simultaneously iteratate over two or more \verb|VCF| readers. For each genomic position with a variant,
    return a list of size equal to the number of VCF readers. This list contains the \verb|VCF| record from
    readers that have this variant, and None for readers that don’t have it. The caller must make sure
    that inputs are sorted in the same way and use the same reference otherwise behaviour is undefined.

    \verb|Args|:
            \verb|vcf_record_sort_key|: \

    function that takes a VCF record and returns a
    tuple that can be used as a key for comparing and sorting \verb|VCF| records across all readers.
    This tuple defines what it means for two variants to be equal (eg. whether it’s only their
    position or also their allele values), and implicitly determines the chromosome ordering since
    the tuple’s 1st element is typically the chromosome name (or calculated from it).


    \item[\texttt{vcf.utils.trim\_common\_suffix(*sequences)}] \

    Trim a list of sequences by removing the longest common suffix while leaving all of them at least one
    character in length. Standard convention with VCF is to place an indel at the left-most position,
    but some tools add additional context to the right of the sequences (e.g. samtools).
    These common suffixes are undesirable when comparing variants, for example in variant databases.

    \begin{verbatim}
    >>> trim_common_suffix('TATATATA', 'TATATA')
    ['TAT', 'T']
    \end{verbatim}


    \begin{verbatim}
    >>> trim_common_suffix('ACCCCC', 'ACCCCCCCC', 'ACCCCCCC', 'ACCCCCCCCC')
    ['A', 'ACCC', 'ACC', 'ACCCC']
    \end{verbatim}

    \

    \end{description}

\section{VCF.Writer class}

\noindent The \verb|VCF.Writer| class provides a way of writing a VCF file.
\verb|VCF.parser| module supports \verb|close()|, \verb|flush()| and \verb|write_record()| methods.

\noindent Currently, when writing new VCF file you must specify a template \verb|VCF.Reader| object
which provides the metadata, like this:

\begin{verbatim}
>>> from Bio.VCF import parser
>>> vcf_reader = parser.Reader(filename='tb.vcf.gz')
>>> vcf_writer = parser.Writer(open('/dev/null', 'w'), vcf_reader)
>>> for record in vcf_reader:
...     vcf_writer.write_record(record)
\end{verbatim}




\section{Retrieving records from VCF file}

\noindent This chapter gives an overview of the functionality of fetch methods included in \verb|VCF| \verb|parser| module.
Those functions enable users to retrieve particular records from VCF file describing structural variants,
depending on provided argument - for example interval of positions within which we seek for structural variants, a list
of such positions or feature type within which structural variants are present.


\noindent Functionality of those fetch methods includes retrieving structural variants corresponding to ranges
provided in BED files as well as features from GFF files. If you are not familiar with BED file format
you might be interested in \href{http://www.ensembl.org/info/website/upload/bed.html}{BED} and
\href{http://gmod.org/wiki/GFF3}{GFF}.


\noindent Most of implementation is based on \verb|pybedtools| module - \href{https://daler.github.io/pybedtools/}{pybedtools},
which support many file formats including VCF, BED and GFF, therefore \verb|pybedtools| package is required.


\noindent Due to enormous sizes of some BED and GFF files, some fetch methods are intended to enable user to provide
stream of particular GFF/BED file from chosen database. It is a beneficial solution allowing users to avoid
the necessity of saving very big files to local disc.


\noindent Below there is a brief description of each fetch method.
All of them have arguments \verb|verbose| and \verb|vcf| specifying if result should be printed to stdout
and whether new VCF.Reader object should be created, respectively.

\begin{description}
  \item[\texttt{fetch\_bed(bed\_file, verbose = True, vcf = None)}] \

    Fetches VCF file records that correspond to regions included in a BED file.
    Fetch is based on pybedtools 'intersect' method and returns a BedTool / VCF.Reader object of selected features.
    BED file must be specified.

  \item[\texttt{fetch\_bed\_fsock(stream, verbose = False, vcf=None)}] \

    This fetch works exactly the same as fetch\_bed(), except the BED file is not required.
    Intervals used for intersection with a VCF file are provided in stream object of chosen BED file.
    This method returns a BedTool object of selected VCF features or new VCF.Reader object.
    Stream of gzipped BED file is required.

  \item[\texttt{fetch\_multilocal(chrom, local\_list, verbose = False, vcf = None)}] \

    Fetches VCF records that correspond to intervals provided in 'local\_list'.
    Local\_list must be a list of tuples (start, end), where start and end coordinates are in the
    zero-based, half-open coordinate system. Function returns selected records as a BedTool object
    or new VCF.Reader object. Chromosome must be specified.

  \item[\texttt{fetch(chrom, interval = None, verbose = True, vcf=None)}] \

    Fetches those records from VCF file that correspond to selected chromosome and
    fit in selected interval (if provided).
    This method creates one-line pybedtool feature based on selected chromosome (and interval = [start,stop]),
    and then uses it in pybedtools intersection method.
    Function returns BedTool object representing selected VCF records or new VCF.Reader object.
    Chromosome must be specified and interval is optional.

  \item[\texttt{fetch\_gff(gff\_file, chrom, feature\_type, location = None, verbose = False, vcf = None)}] \

    This method enables to select desired features from a GFF/GFF2/GFF3 file and fetch VCF records
    that correspond to position of those features. Fetch is based on pybedtools 'intersection' method and returns
    a BedTool object of chosen VCF records or new VCF.Reader object.
    Gff file, chromosome and feature type are required.
    Selection of desired features from a GFF/GFF2/GFF3 file with a specified location is possible when
    provided optional parameter 'location=[start,end]'.

  \item[\texttt{fetch\_gff\_fsock(self, stream, chrom, feature\_type, location = None, verbose = False, vcf = None)}] \

    This method works exactly the same as fetch\_gff(), except the GFF file is not required.
    The GFF file is replaced with a stream object from chosen database.
    Method returns a BedTool object of selected VCF records or new VCF.Reader object.
    Stream of gzipped file must be provided.

\end{description}


\noindent The following sections present exemplary use of fetch methods.


\subsection{Create VCF.Reader object}
\label{sec:object}


\noindent Since all fetch methods are included in VCF.Reader class, we need to create \verb|Reader| object. But first of all,
we need to import Bio.VCF library:


\begin{verbatim}
>>> from Bio import VCF
>>> from VCF import parser

\end{verbatim}

and then create a VCF.Reader obcject. We can either create object from a local file or we can provide fsock
of corresponding VCF file:


\begin{verbatim}
>>> vcf=parser.Reader(open('Tests/VCF/chr13.vcf'))

\end{verbatim}

\subsubsection{Fetching records depending on BED/GFF file}


\noindent Suppose we have a BED file with positions of CTCF motif binding sites. We want to collect all structural variants
located within those sites. If we have this BED file locally on our computer, then we should simply run:


\begin{verbatim}
>>> vcf.fetch_bed('VCF/chr13bed.bed')

\end{verbatim}


or if we don't, we should provide a stream of chosen BED file and use:


\begin{verbatim}
>>> stream="ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606/BED/bed_chr_13.bed.gz"
>>> vcf.fetch_bed_fsock(stream)

\end{verbatim}


\noindent Selected structural variants are returned in BedTools object (if vcf = None) and can be easily accessed, for example
if we want to see all information of every selected record:


\begin{verbatim}
>>> bed = vcf.fetch_bed('VCF/chr13bed.bed')
>>> for b in bed:
>>>     print (b.fields)
['chr13', '10', '.', 'G', 'GGT', '.', 'PASS', 'DP=91;SS=1;SSC=2;GPV=3.0109E-23;SPV=5.8324E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','0/1:.:36:13:22:62.86%:2,11,1,21']
['chr13', '20', '.', 'GT', 'G', '.', 'PASS', 'DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:28:5:22:81.48%:0,5,1,21']
['chr13', '40', '.', 'AAAC', 'A', '.', 'PASS', 'DP=42;SS=1;SSC=12;GPV=7.3092E-18;SPV=6.278E-2',
'GT:GQ:DP:RD:AD:FREQ:DP4','0/1:.:13:4:9:69.23%:4,0,9,0']
['chr13', '50', '.', 'TC', 'T', '.', 'PASS', 'DP=41;SS=1;SSC=2;GPV=9.8874E-23;SPV=5.3659E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:22:1:21:95.45%:1,0,15,6']
['chr13', '60', '.', 'T', 'TTAA', '.', 'PASS', 'DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:12:0:12:100%:0,0,0,12']
\end{verbatim}


\noindent Similarly, we can extract structural variants corresponding to positions of chosen features from GFF file. Suppose
we have a GFF3 file of Homo sapiens, but we are interested only in variants located within pseudogenes
at 13th chromosome. \verb|fetch_gff()| method is what we need:


\begin{verbatim}
>>> vcf.fetch_gff('VCF/HS_fetch_gff.gff3', '13', 'pseudogene')
\end{verbatim}


\noindent What is more, if we want variant within pseudogenes which are within specific positions, we can add
\verb|location| argument:


\begin{verbatim}
>>> vcf.fetch_gff('VCF/HS_fetch_gff.gff3', '13', 'pseudogene', location=[1, 18270822])
Finding SV corresponding to pseudogene and chosen position
chr13	20	.	GT	G	.	PASS	DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:28:5:22:81.48%:0,5,1,21
chr13	30	.	AC	A	.	PASS	DP=22;SS=1;SSC=7;GPV=1.3117E-10;SPV=1.9481E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:10:2:8:80%:0,2,0,8
chr13	40	.	AAAC	A	.	PASS	DP=42;SS=1;SSC=12;GPV=7.3092E-18;SPV=6.278E-2	GT:GQ:DP:RD:AD:FREQ:DP4
0/1:.:13:4:9:69.23%:4,0,9,0
chr13	50	.	TC	T	.	PASS	DP=41;SS=1;SSC=2;GPV=9.8874E-23;SPV=5.3659E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:22:1:21:95.45%:1,0,15,6
chr13	60	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
chr13	9542346	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
\end{verbatim}


\noindent As in case of fetch depending on BED file, we can use stream of GFF file instead of local file.


\subsubsection{Fetching records depending on interval}


\noindent We might have a VCF file which have records referring to different chromosomes. In such case, we want to be able to
analyze only those variants that are located on chromosome of our interest. We can simply use \verb|fetch()| method
on our \verb|vcf| object, but as we want to analyze fetched records further, we should use argument specifying
new vcf.Reader object:


\begin{verbatim}
>>> v=vcf.fetch('chr13',vcf='new_vcf')
>>> v
<parser.Reader object at 0x7eff4df8f2b0>

\end{verbatim}


\noindent Now, when we have all variants located on chromosome 13, we can choose only those within specified intervals:


\begin{verbatim}
>>> v.fetch_multilocal('chr13',[[10, 30], [80, 100], [85837129, 100000000]])
chr13	20	.	GT	G	.	PASS	DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:28:5:22:81.48%:0,5,1,21
chr13	30	.	AC	A	.	PASS	DP=22;SS=1;SSC=7;GPV=1.3117E-10;SPV=1.9481E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:10:2:8:80%:0,2,0,8
chr13	85837130	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
<BedTool(/tmp/pybedtools.dbyw5lct.tmp)>

\end{verbatim}


\noindent VCF file created after \verb|vcf.fetch| is saved to local disc and can be easily achieved with
VCF.Reader() anytime needed.

\section{Available VCF Databases}

\noindent Bio.VCF.databases is a Biopython module that supports \verb|1001 Genomes| and \verb|dbSNP| databases.
Since most of VCF files are of enormous sizes, it is convenient to use streams instead of local files.
Functionality of this package enables users to search through above-mentioned databases, and use selected streams
of VCF files as VCF.Reader objects in further analysis.


\noindent If you are not familiar with \verb|1001 Genomes| and \verb|dbSNP| databases you might be interested in
\href{http://1001genomes.org/}{1001 Genomes} and \href{https://www.ncbi.nlm.nih.gov/SNP/}{dbSNP}. However, following
sections provide brief description of methods searching through both databases as well as some information about them.


\subsection{1001 Genomes database}
\label{sec:object}


\verb|1001 Genomes| database was launched to discover whole-genome variation of the \verb|Arabidopsis Thaliana| strains.
\verb|Bio.VCf.databases| module supports current database's version which includes analysis of 1135 genomes achieved
during the first phase of the project.
Searching through the database can be based on strain's name, ec number, eco type, as well as on information of its
origin - such as country, longitude or latitude.


\noindent Below there is a brief description of \verb|thousandgenome()| methods:


\begin{description}
  \item[\texttt{thousandgenomes(name, ecotype, ecnumber, country, longitude, latitude)}] \

    This method enables to search through \verb|1001 Genomes| database for VCF file corresponding to selected
    Arabidopsis Thaliana strain, origin country or longitude and/or latitude where Arabidopsis Thaliana live.

    Country name must be chosen from: "USA", "FRA", "CZE", "AUT", "KGZ", "TJK", "SWE", "UK", "GER", "KAZ",
    "BEL", "CPV", "ESP", "RUS", "NED", "FIN", "SUI", "ITA", "IRL", "POR", "EST", "DEN", "IND", "LTU", "JPN", "POL", "NOR",
    "CAN", "UKR", "AZE", "GEO", "ARM", "MAR", "CRO", "BUL", "GRC", "SVK", "ROU", "UZB", "SRB", "CHN", "IRN", "LBN", "MAR",
    "AFG".
    Longitude and latitude should be provided as an interval - longitude = (int1, int2), latitude = (int1,int2).
    Strain names, eco types and ec numbers are unique, country, while longitude and latitude enables users to seek for
    multiple VCF files corresponding to selected features.
    Method returns VCF.Reader object of selected VCF file stream from 1001 Genomes Database or a list of
    such VCF.Reader objects.

\item[\texttt{download(vcf\_reader, path\_filename)}] \

    Downloads VCF file corresponding to stream on which provided VCF.Reader object is initialized.
    VCF.Reader object as well as download directory and filename are required.


\end{description}

\noindent Let's try some functionality of the module:

\noindent Suppose we want to analyse structural variants identified in "CYR" strain of Arabidopsis Thaliana. First of all,
we need to find VCF file corresponding to our selected strain. To do so, we can simply type:


\begin{verbatim}
>>> from Bio.VCF import databases
>>> vcf = databases.thousandgenomes("CYR")
>>> vcf
<Bio.VCF.parser.Reader object at 0x7f4bf49feef0>

\end{verbatim}


\noindent Now, we can continue analysis for example by running methods from VCF.Reader class.


\noindent We may also be interested in retrieving all structural variants that are identified in strains occupying a particular
territory, such as area of longitude (-73.1494, -73.1492) and latitude (40.9063, 40.9064). Module's \verb|thousandgenomes()|
method can manage this:


\begin{verbatim}
>>> vcf_list = databases.thousandgenomes(longitude=(-73.1494, -73.1492), latitude=(40.9063, 40.9064))
>>> vcf_list
[<Bio.VCF.parser.Reader object at 0x7f4bf4a0d978>, <Bio.VCF.parser.Reader object at 0x7f4bf4a1e080>]

\end{verbatim}


\noindent Method returned two VCF.Reader objects which we can analyse further or simply download to local disc:


\begin{verbatim}
>>> for v in vcf_list:
>>>     databases.download(v,'database_download.gz')
\end{verbatim}

\subsection{dbSNP database}

\verb|dbSNP| Is the NCBI Short Genetic Variations database. It catalogs short variations in nucleotide sequences froma wide range of organisms. 
\verb|Bio.VCf.databases| module can be used to obtain avaiable VCF files from dbSNP. List of organism for which VCF files exists can be found in supplementary file \verb|organisms.txt|. The database is regulary updated. User can update list od organisms using attached methods. Searching through the database can be based on organism and taxon ID proposed in file \verb|organisms.txt| and a chosen chromosome. Unfortunatelly dbSNP does not contain human SNPs divided into chromosomes. User can operate only on a very big file (350GB).

\noindent Below there is a brief description of \verb|dbSNP| methods:

\begin{description}
  \item[\texttt{dbSNP\_download(organism\_taxon, chromosome = None)}] \

    This method enables to search through \verb|dbSNP| database for VCF file corresponding to selected
    organism, taxon and chromosome.
    
    Organism and corresponding taxon ID must be chosen from list of organisms in \verb|organisms.txt|. User can update this list by running
    \verb|check_VCF()| method.
    
    Chromosome must be chosen from existing chromosomes in given organism. Leaving \verb|chromosome=None| will cause loading VCF file
    containing all the chromosomes (but not every organism has this file).
    
    Method returns VCF.Reader object of selected VCF file stream from dbSNP.
    
    \item[\texttt{check\_VCF()}] \
    
    This method enables to update organisms list in \verb|organisms.txt|. dbSNP is regullary updated. If you can't find chosen organisms in 
    the list we recommend running this method. 

\end{description}

\noindent Let's try some functionality of the module:

\noindent Suppose we want to analyse SNPs found in chromosome 2R in fruitfly. We check \verb|organisms.txt| where we can find identifier 
fruitfly\_7227.

\begin{verbatim}
>>> from Bio.VCF import databases
>>> vcf = databases.dbSNP_download('fruitfly_7227',chromosome='2R')
>>> vcf
<Bio.VCF.parser.Reader object at 0x7f1d813f14d0>
\end{verbatim}

\noindent Now we can continue our analysis using methods proposed in VCF.Reader class.

\noindent We can also want to analyse all SNPs found for flycatcher:

\begin{verbatim}
>>> vcf = databases.dbSNP_download('flycatcher_59894')
>>> vcf
<Bio.VCF.parser.Reader object at 0x7f1d82c83ad0>
\end{verbatim}

\noindent If you want to check if new VCF files are avaiable just run:

\begin{verbatim}
>>> from Bio.VCF import databases
>>> databases.check_VCF()
Connecting to database...
Searching for VCF files...
Searching for VCF files...
Searching for VCF files...
Searching for VCF files...
Searching for VCF files...
.
.
.
List updated.
\end{verbatim}
    
    
\section {Retrieving records from phasing files}
%todo Hans

This chapter gives an overview of the usage of phasing files parser included in \verb|Bio.VCF| \verb|phase| module.
This module makes handling haplotype data easier, allowing users to retrieve particular records from phasing files
and even filtering SNPs by matching them to those included in VCF file.

The whole module is specifficaly written for handling data from \href{ftp://ftp.hapmap.org/hapmap/phasing/2009-02\_phaseIII/HapMap3\_r2/}{HapMap 3} project.
Format of the data handled by functions is as staded in \href{ftp://ftp.hapmap.org/hapmap/phasing/2009-02\_phaseIII/HapMap3\_r2/hapmap3\_r2\_phasing\_summary.doc}{hapmap3\_r2\_phasing\_summary.doc},
but also assuming that SNPs in those files are sorted increasingly by position.


\subsection{Parsing and reading phasing files}

Phasing data can be read as \verb|VCF.PhasedReader| object. It is similiar to \verb|VCF.Reader| class - works with both compressed (.gz) and
uncompressed files, can take fsocks (streams) and filenames as input, with specified encoding (default is ascii).
\verb|VCF.PhasedReader| holds information extracted from the name of the file (if available), haplotypes, and SNP's in form of \verb|VCF._PhasedRecord| objects.
It also contains several useful functions explained further in the coresponding subsections in \verb|VCF.PhasedReader functions| section below.
Important thing is, if you are downloading the .phased file to your computer, rather not change the file name as it gives important
information not stated anywhere in the file. Files without original name will be parsed normally but will lack in information like:
\begin{enumerate}
  \item chromosome
  \item region
  \item if the file is for unrelated haplotypes, duos or trios.
\end{enumerate}

\subsubsection{Creating VCF.PhasedReader objects}

\noindent Suppose we have a phasing file downloaded from the \href{ftp://ftp.hapmap.org/hapmap/phasing/2009-02\_phaseIII/HapMap3\_r2/}{HapMap 3} site.
We can read it in several ways, in example supporting only the filename:

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> phase_reader = PhasedReader('hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> phase_reader
<Bio.VCF.phase.PhasedReader object at 0x7fee0c0445c0>

\end{verbatim}

\noindent or with opening the file first:

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> phase_file = open('hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> phase_reader = PhasedReader(fsock = phase_file)
>>> phase_reader
<Bio.VCF.phase.PhasedReader object at 0x7fee0c04bd30>

\end{verbatim}

\noindent If the file is compressed (.gz), the parser will try to guess it and uncompress it without stating anything, but it is advised that the uncompressed argument is set
to true:

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> phase_reader = PhasedReader('hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased.gz',
compressed=True)
>>> phase_reader
<Bio.VCF.phase.PhasedReader object at 0x7fedf6df1278>

\end{verbatim}

\subsubsection{Exploring data held by VCF.PhasedReader}

\noindent Data extracted from the filename is stored in the VCF.PhasedReader.filedata dict.

\begin{verbatim}
>>> phase_reader.filedata
{'region': 'yri', 'chrom': '10', 'data_type': 'duos'}

\end{verbatim}

\noindent It is possible to get to the particular information by calling its key from dict:

\begin{verbatim}
>>> phase_reader.filedata['region']
'yri'
>>> phase_reader.filedata['chrom']
'10'
>>> phase_reader.filedata['data_type']
'duos'

\end{verbatim}

\noindent Haplotypes included in the file are stored in the haplotypes list, as \_Haplotype objects:

\begin{verbatim}
>>> phase_reader.haplotypes
[<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e828>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e898>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e908>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e940>,
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e9b0>,
.
.
.

\end{verbatim}

\noindent Let's see the first haplotype in the file:

\begin{verbatim}
>>> phase_reader.haplotypes[0]
<Bio.VCF.phase._Haplotype object at 0x7fb16ed6e828>
>>> print(phase_reader.haplotypes[0])
NA18855, transmitted: True

\end{verbatim}

\noindent The \_Haplotype object holds information about the name of haplotype and if it is transmitted:

\begin{verbatim}
>>> phase_reader.haplotypes[0].name
'NA18855'
>>> phase_reader.haplotypes[0].is_transmitted
True

\end{verbatim}

\subsubsection{Parsing phasing files with VCF.PhasedReader}

\noindent To get the first (and then next, and then next...) line of the file, you just call next() on the PhasedReader:

\begin{verbatim}
>>> rec = next(phase_reader)
>>> rec
<Bio.VCF.phase._PhasedRecord object at 0x7fb16ed7f6d8>
>>> print(rec)
Record(rs12255619 at 88481: C, A, A, A, A, A, A, A, A, A, A, A)

\end{verbatim}

\noindent Parsing the phasing file by iterating over it is also possible:

\begin{verbatim}
>>> for rec in phase_reader:
...     print(rec)
...
Record(rs12255619 at 88481: C, A, A, A, A, A, A, A, A, A, A, A)
Record(rs11252546 at 94427: T, T, T, T, T, T, T, T, C, T, T, T)
Record(rs17156316 at 191762: T, T, T, T, T, T, T, C, C, T, T, T)
Record(rs10903451 at 193471: A, A, A, A, G, G, A, A, A, A, A, G)
Record(rs11250575 at 199448: T, C, C, C, C, C, C, C, C, C, C, C)
.
.
.

\end{verbatim}

\noindent Let's explore what is stored in the \_PhasedRecord:
\begin{enumerate}
\item rsID of the SNP
\begin{verbatim}
>>> rec.rsID
'rs12255619'
\end{verbatim}

\item record position on the chromosome:
\begin{verbatim}
>>> rec.pos
88481
\end{verbatim}

\item samples included in the record (as list of \_Sample objects):
\begin{verbatim}
>>> rec.samples
[<Bio.VCF.phase._Sample object at 0x7f38a3d20a90>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d048>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d080>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d0b8>,
<Bio.VCF.phase._Sample object at 0x7f38a3d3d160>,
.
.
.
\end{verbatim}
\end{enumerate}

\noindent The \_Sample object corresponds to the nucleotide in the particular haplotype for the particular SNP:

\begin{verbatim}
>>> rec.samples[0]
<Bio.VCF.phase._Sample object at 0x7f38a3d20a90>
>>> rec.samples[0].rsID, rec.samples[0].haplotype.name, rec.samples[0].nucleotide
('rs12255619', 'NA18855', 'C')
\end{verbatim}

\noindent \_Sample also holds information if the particular SNP for the haplotype exists and if it's unresolved:

\begin{verbatim}
>>> rec.samples[0].exists, rec.samples[0].is_unresolved
(True, False)
\end{verbatim}

\noindent There is also the is\_not\_matching\_snp argument, but it is further discussed in the \verb|VCF.PhasedReader.fetch()|
section.

\subsection{VCF.PhasedReader functions}

\subsubsection{VCF.PhasedReader.fetch() - Fetching SNP's from VCF file}

\noindent The fetch metod retrieves SNPs corresponding to those in provided VCF file. It creates \verb|VCF.Reader|
and filters it to have only the SNP's, then finds the matching ones in the phasing file. It returns the next PhasedReader object, but only with matching records.
It takes the same arguments as VCF.Reader when it is created (see in the section about \verb|VCF.Reader| above) and a few more:

\begin{enumerate}
  \item verbose (default True) - if the found records should be printed out
  \item vcf (default None) - the argument for VCF.Reader.fetch, see above
  \item not\_matching\_snp (default ".") - what should be put after the nucleotide not matching any of the alleles in the VCF.
  If None, nucleotide is outputted normally.
\end{enumerate}

\noindent Remember that all the functions in the PhasedReader objects, especially fetch, treats the phasing file as sorted by position.
\\

\noindent Suppose you wanted to filter the SNPs in the phasing files with the VCF file with some records for the same chromosome.
First you need to create the PhasedReader object, and then fetch it by supplying the same arguments as you would when creating the VCF.Reader object.

\begin{verbatim}
>>> phase_reader = PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased.gz',
compressed = True)
>>> phase_reader.fetch(filename = 'Tests/VCF/chr10.vcf',compressed = True)
rs12255619	88481	C A A A A A A A A A A A
rs1904671	1004603	A G. A A A A G. G. A A A A
rs11812734	31713857	A G A A G G G G A G G G
<Bio.VCF.phase.PhasedReader object at 0x7f38a3d3d128>
\end{verbatim}

\noindent If you don't want dots, or any sign after the not-matching SNPs, set not\_matching\_snp to None:

\begin{verbatim}
>>> phase_reader.fetch(filename = 'Tests/VCF/chr10.vcf',not_matching_snp = None)
rs12255619	88481	C A A A A A A A A A A A
rs1904671	1004603	A G A A A A G G A A A A
rs11812734	31713857	A G A A G G G G A G G G
<Bio.VCF.phase.PhasedReader object at 0x7f38a3d20b70>
\end{verbatim}

\noindent Or if you don't want the lines to be printed and just have the new reader, simply change the verbose to False:

\begin{verbatim}
>>> phase_reader.fetch(filename = 'Tests/VCF/chr10.vcf',verbose=False)
<Bio.VCF.phase.PhasedReader object at 0x7f38a3d3d518>
\end{verbatim}

\subsubsection{VCF.PhasedReader.get_snp_with_specific_id(rsID) - Getting SNP with user-given rsID}

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> reader = VCF.PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> reader.get_snp_with_specific_id('rs2066314')
<Bio.VCF.phase._PhasedRecord object at 0x7fe67d7a7e50>
>>> reader = VCF.PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> print reader.get_snp_with_specific_id('rs2066314')
Record(rs2066314 at 504032: C, C, C, G, C, G, C, C, C, C, C, C)

\end{verbatim}

\subsubsection{VCF.PhasedReader.get_snp_within_range(self, pos1, pos2) - Getting SNPs within user-given range of positions}

\noindent pos1 and pos2 arguments stand for a beginning and an ending position of the range (respectively) within which we are looking for SNPs.

\begin{verbatim}
>>> from Bio.VCF import PhasedReader
>>> reader = VCF.PhasedReader('Tests/VCF/hapmap3_r2_b36_fwd.consensus.qc.poly.chr10_yri.D.phased')
>>> reader.get_snp_within_range(418076, 504032)
SNPs found: 3

[<Bio.VCF.phase._PhasedRecord object at 0x7f3e13b30dd0>, <Bio.VCF.phase._PhasedRecord object at 0x7f3e13b30750>, <Bio.VCF.phase._PhasedRecord object at 0x7f3e13b33150>]

\end{verbatim}

\subsection{VCF.PhasedReader.get_snp_with_specific_sample(haplotype, nucleotide) - Getting SNPs with user-given details of the searched sample}


\noindent haplotype argument gives the information of the name of the haplotype which is of user's interest.
nucleotide argument gives the information on the specific nucleotide ('A', 'T', 'G', 'C') ......



